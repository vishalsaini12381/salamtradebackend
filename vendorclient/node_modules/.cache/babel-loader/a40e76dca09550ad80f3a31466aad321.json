{"ast":null,"code":"/**\n * Copyright 2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactElementValidator\n */\n\n/**\n * ReactElementValidator provides a wrapper around a element factory\n * which validates the props passed to the element. This is intended to be\n * used only in DEV and could be replaced by a static type checker for languages\n * that support it.\n */\n\"use strict\";\n\nvar ReactElement = require(\"./ReactElement\");\n\nvar ReactPropTypeLocations = require(\"./ReactPropTypeLocations\");\n\nvar ReactCurrentOwner = require(\"./ReactCurrentOwner\");\n\nvar monitorCodeUse = require(\"./monitorCodeUse\");\n\nvar warning = require(\"./warning\");\n/**\n * Warn if there's no key explicitly set on dynamic arrays of children or\n * object keys are not valid. This allows us to keep track of children between\n * updates.\n */\n\n\nvar ownerHasKeyUseWarning = {\n  'react_key_warning': {},\n  'react_numeric_key_warning': {}\n};\nvar ownerHasMonitoredObjectMap = {};\nvar loggedTypeFailures = {};\nvar NUMERIC_PROPERTY_REGEX = /^\\d+$/;\n/**\n * Gets the current owner's displayName for use in warnings.\n *\n * @internal\n * @return {?string} Display name or undefined\n */\n\nfunction getCurrentOwnerDisplayName() {\n  var current = ReactCurrentOwner.current;\n  return current && current.constructor.displayName || undefined;\n}\n/**\n * Warn if the component doesn't have an explicit key assigned to it.\n * This component is in an array. The array could grow and shrink or be\n * reordered. All children that haven't already been validated are required to\n * have a \"key\" property assigned to it.\n *\n * @internal\n * @param {ReactComponent} component Component that requires a key.\n * @param {*} parentType component's parent's type.\n */\n\n\nfunction validateExplicitKey(component, parentType) {\n  if (component._store.validated || component.key != null) {\n    return;\n  }\n\n  component._store.validated = true;\n  warnAndMonitorForKeyUse('react_key_warning', 'Each child in an array should have a unique \"key\" prop.', component, parentType);\n}\n/**\n * Warn if the key is being defined as an object property but has an incorrect\n * value.\n *\n * @internal\n * @param {string} name Property name of the key.\n * @param {ReactComponent} component Component that requires a key.\n * @param {*} parentType component's parent's type.\n */\n\n\nfunction validatePropertyKey(name, component, parentType) {\n  if (!NUMERIC_PROPERTY_REGEX.test(name)) {\n    return;\n  }\n\n  warnAndMonitorForKeyUse('react_numeric_key_warning', 'Child objects should have non-numeric keys so ordering is preserved.', component, parentType);\n}\n/**\n * Shared warning and monitoring code for the key warnings.\n *\n * @internal\n * @param {string} warningID The id used when logging.\n * @param {string} message The base warning that gets output.\n * @param {ReactComponent} component Component that requires a key.\n * @param {*} parentType component's parent's type.\n */\n\n\nfunction warnAndMonitorForKeyUse(warningID, message, component, parentType) {\n  var ownerName = getCurrentOwnerDisplayName();\n  var parentName = parentType.displayName;\n  var useName = ownerName || parentName;\n  var memoizer = ownerHasKeyUseWarning[warningID];\n\n  if (memoizer.hasOwnProperty(useName)) {\n    return;\n  }\n\n  memoizer[useName] = true;\n  message += ownerName ? \" Check the render method of \" + ownerName + \".\" : \" Check the renderComponent call using <\" + parentName + \">.\"; // Usually the current owner is the offender, but if it accepts children as a\n  // property, it may be the creator of the child that's responsible for\n  // assigning it a key.\n\n  var childOwnerName = null;\n\n  if (component._owner && component._owner !== ReactCurrentOwner.current) {\n    // Name of the component that originally created this child.\n    childOwnerName = component._owner.constructor.displayName;\n    message += \" It was passed a child from \" + childOwnerName + \".\";\n  }\n\n  message += ' See http://fb.me/react-warning-keys for more information.';\n  monitorCodeUse(warningID, {\n    component: useName,\n    componentOwner: childOwnerName\n  });\n  console.warn(message);\n}\n/**\n * Log that we're using an object map. We're considering deprecating this\n * feature and replace it with proper Map and ImmutableMap data structures.\n *\n * @internal\n */\n\n\nfunction monitorUseOfObjectMap() {\n  var currentName = getCurrentOwnerDisplayName() || '';\n\n  if (ownerHasMonitoredObjectMap.hasOwnProperty(currentName)) {\n    return;\n  }\n\n  ownerHasMonitoredObjectMap[currentName] = true;\n  monitorCodeUse('react_object_map_children');\n}\n/**\n * Ensure that every component either is passed in a static location, in an\n * array with an explicit keys property defined, or in an object literal\n * with valid key property.\n *\n * @internal\n * @param {*} component Statically passed child of any type.\n * @param {*} parentType component's parent's type.\n * @return {boolean}\n */\n\n\nfunction validateChildKeys(component, parentType) {\n  if (Array.isArray(component)) {\n    for (var i = 0; i < component.length; i++) {\n      var child = component[i];\n\n      if (ReactElement.isValidElement(child)) {\n        validateExplicitKey(child, parentType);\n      }\n    }\n  } else if (ReactElement.isValidElement(component)) {\n    // This component was passed in a valid location.\n    component._store.validated = true;\n  } else if (component && typeof component === 'object') {\n    monitorUseOfObjectMap();\n\n    for (var name in component) {\n      validatePropertyKey(name, component[name], parentType);\n    }\n  }\n}\n/**\n * Assert that the props are valid\n *\n * @param {string} componentName Name of the component for error messages.\n * @param {object} propTypes Map of prop name to a ReactPropType\n * @param {object} props\n * @param {string} location e.g. \"prop\", \"context\", \"child context\"\n * @private\n */\n\n\nfunction checkPropTypes(componentName, propTypes, props, location) {\n  for (var propName in propTypes) {\n    if (propTypes.hasOwnProperty(propName)) {\n      var error; // Prop type validation may throw. In case they do, we don't want to\n      // fail the render phase where it didn't fail before. So we log it.\n      // After these have been cleaned up, we'll let them throw.\n\n      try {\n        error = propTypes[propName](props, propName, componentName, location);\n      } catch (ex) {\n        error = ex;\n      }\n\n      if (error instanceof Error && !(error.message in loggedTypeFailures)) {\n        // Only monitor this failure once because there tends to be a lot of the\n        // same error.\n        loggedTypeFailures[error.message] = true; // This will soon use the warning module\n\n        monitorCodeUse('react_failed_descriptor_type_check', {\n          message: error.message\n        });\n      }\n    }\n  }\n}\n\nvar ReactElementValidator = {\n  createElement: function (type, props, children) {\n    // We warn in this case but don't throw. We expect the element creation to\n    // succeed and there will likely be errors in render.\n    \"production\" !== process.env.NODE_ENV ? warning(type != null, 'React.createElement: type should not be null or undefined. It should ' + 'be a string (for DOM elements) or a ReactClass (for composite ' + 'components).') : null;\n    var element = ReactElement.createElement.apply(this, arguments); // The result can be nullish if a mock or a custom function is used.\n    // TODO: Drop this when these are no longer allowed as the type argument.\n\n    if (element == null) {\n      return element;\n    }\n\n    for (var i = 2; i < arguments.length; i++) {\n      validateChildKeys(arguments[i], type);\n    }\n\n    if (type) {\n      var name = type.displayName;\n\n      if (type.propTypes) {\n        checkPropTypes(name, type.propTypes, element.props, ReactPropTypeLocations.prop);\n      }\n\n      if (type.contextTypes) {\n        checkPropTypes(name, type.contextTypes, element._context, ReactPropTypeLocations.context);\n      }\n    }\n\n    return element;\n  },\n  createFactory: function (type) {\n    var validatedFactory = ReactElementValidator.createElement.bind(null, type);\n    validatedFactory.type = type;\n    return validatedFactory;\n  }\n};\nmodule.exports = ReactElementValidator;","map":null,"metadata":{},"sourceType":"script"}