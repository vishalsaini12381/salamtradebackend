{"ast":null,"code":"/**\n * Copyright 2013-2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactComponent\n */\n\"use strict\";\n\nvar ReactElement = require(\"./ReactElement\");\n\nvar ReactOwner = require(\"./ReactOwner\");\n\nvar ReactUpdates = require(\"./ReactUpdates\");\n\nvar assign = require(\"./Object.assign\");\n\nvar invariant = require(\"./invariant\");\n\nvar keyMirror = require(\"./keyMirror\");\n/**\n * Every React component is in one of these life cycles.\n */\n\n\nvar ComponentLifeCycle = keyMirror({\n  /**\n   * Mounted components have a DOM node representation and are capable of\n   * receiving new props.\n   */\n  MOUNTED: null,\n\n  /**\n   * Unmounted components are inactive and cannot receive new props.\n   */\n  UNMOUNTED: null\n});\nvar injected = false;\n/**\n * Optionally injectable environment dependent cleanup hook. (server vs.\n * browser etc). Example: A browser system caches DOM nodes based on component\n * ID and must remove that cache entry when this instance is unmounted.\n *\n * @private\n */\n\nvar unmountIDFromEnvironment = null;\n/**\n * The \"image\" of a component tree, is the platform specific (typically\n * serialized) data that represents a tree of lower level UI building blocks.\n * On the web, this \"image\" is HTML markup which describes a construction of\n * low level `div` and `span` nodes. Other platforms may have different\n * encoding of this \"image\". This must be injected.\n *\n * @private\n */\n\nvar mountImageIntoNode = null;\n/**\n * Components are the basic units of composition in React.\n *\n * Every component accepts a set of keyed input parameters known as \"props\" that\n * are initialized by the constructor. Once a component is mounted, the props\n * can be mutated using `setProps` or `replaceProps`.\n *\n * Every component is capable of the following operations:\n *\n *   `mountComponent`\n *     Initializes the component, renders markup, and registers event listeners.\n *\n *   `receiveComponent`\n *     Updates the rendered DOM nodes to match the given component.\n *\n *   `unmountComponent`\n *     Releases any resources allocated by this component.\n *\n * Components can also be \"owned\" by other components. Being owned by another\n * component means being constructed by that component. This is different from\n * being the child of a component, which means having a DOM representation that\n * is a child of the DOM representation of that component.\n *\n * @class ReactComponent\n */\n\nvar ReactComponent = {\n  injection: {\n    injectEnvironment: function (ReactComponentEnvironment) {\n      \"production\" !== process.env.NODE_ENV ? invariant(!injected, 'ReactComponent: injectEnvironment() can only be called once.') : invariant(!injected);\n      mountImageIntoNode = ReactComponentEnvironment.mountImageIntoNode;\n      unmountIDFromEnvironment = ReactComponentEnvironment.unmountIDFromEnvironment;\n      ReactComponent.BackendIDOperations = ReactComponentEnvironment.BackendIDOperations;\n      injected = true;\n    }\n  },\n\n  /**\n   * @internal\n   */\n  LifeCycle: ComponentLifeCycle,\n\n  /**\n   * Injected module that provides ability to mutate individual properties.\n   * Injected into the base class because many different subclasses need access\n   * to this.\n   *\n   * @internal\n   */\n  BackendIDOperations: null,\n\n  /**\n   * Base functionality for every ReactComponent constructor. Mixed into the\n   * `ReactComponent` prototype, but exposed statically for easy access.\n   *\n   * @lends {ReactComponent.prototype}\n   */\n  Mixin: {\n    /**\n     * Checks whether or not this component is mounted.\n     *\n     * @return {boolean} True if mounted, false otherwise.\n     * @final\n     * @protected\n     */\n    isMounted: function () {\n      return this._lifeCycleState === ComponentLifeCycle.MOUNTED;\n    },\n\n    /**\n     * Sets a subset of the props.\n     *\n     * @param {object} partialProps Subset of the next props.\n     * @param {?function} callback Called after props are updated.\n     * @final\n     * @public\n     */\n    setProps: function (partialProps, callback) {\n      // Merge with the pending element if it exists, otherwise with existing\n      // element props.\n      var element = this._pendingElement || this._currentElement;\n      this.replaceProps(assign({}, element.props, partialProps), callback);\n    },\n\n    /**\n     * Replaces all of the props.\n     *\n     * @param {object} props New props.\n     * @param {?function} callback Called after props are updated.\n     * @final\n     * @public\n     */\n    replaceProps: function (props, callback) {\n      \"production\" !== process.env.NODE_ENV ? invariant(this.isMounted(), 'replaceProps(...): Can only update a mounted component.') : invariant(this.isMounted());\n      \"production\" !== process.env.NODE_ENV ? invariant(this._mountDepth === 0, 'replaceProps(...): You called `setProps` or `replaceProps` on a ' + 'component with a parent. This is an anti-pattern since props will ' + 'get reactively updated when rendered. Instead, change the owner\\'s ' + '`render` method to pass the correct value as props to the component ' + 'where it is created.') : invariant(this._mountDepth === 0); // This is a deoptimized path. We optimize for always having a element.\n      // This creates an extra internal element.\n\n      this._pendingElement = ReactElement.cloneAndReplaceProps(this._pendingElement || this._currentElement, props);\n      ReactUpdates.enqueueUpdate(this, callback);\n    },\n\n    /**\n     * Schedule a partial update to the props. Only used for internal testing.\n     *\n     * @param {object} partialProps Subset of the next props.\n     * @param {?function} callback Called after props are updated.\n     * @final\n     * @internal\n     */\n    _setPropsInternal: function (partialProps, callback) {\n      // This is a deoptimized path. We optimize for always having a element.\n      // This creates an extra internal element.\n      var element = this._pendingElement || this._currentElement;\n      this._pendingElement = ReactElement.cloneAndReplaceProps(element, assign({}, element.props, partialProps));\n      ReactUpdates.enqueueUpdate(this, callback);\n    },\n\n    /**\n     * Base constructor for all React components.\n     *\n     * Subclasses that override this method should make sure to invoke\n     * `ReactComponent.Mixin.construct.call(this, ...)`.\n     *\n     * @param {ReactElement} element\n     * @internal\n     */\n    construct: function (element) {\n      // This is the public exposed props object after it has been processed\n      // with default props. The element's props represents the true internal\n      // state of the props.\n      this.props = element.props; // Record the component responsible for creating this component.\n      // This is accessible through the element but we maintain an extra\n      // field for compatibility with devtools and as a way to make an\n      // incremental update. TODO: Consider deprecating this field.\n\n      this._owner = element._owner; // All components start unmounted.\n\n      this._lifeCycleState = ComponentLifeCycle.UNMOUNTED; // See ReactUpdates.\n\n      this._pendingCallbacks = null; // We keep the old element and a reference to the pending element\n      // to track updates.\n\n      this._currentElement = element;\n      this._pendingElement = null;\n    },\n\n    /**\n     * Initializes the component, renders markup, and registers event listeners.\n     *\n     * NOTE: This does not insert any nodes into the DOM.\n     *\n     * Subclasses that override this method should make sure to invoke\n     * `ReactComponent.Mixin.mountComponent.call(this, ...)`.\n     *\n     * @param {string} rootID DOM ID of the root node.\n     * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction\n     * @param {number} mountDepth number of components in the owner hierarchy.\n     * @return {?string} Rendered markup to be inserted into the DOM.\n     * @internal\n     */\n    mountComponent: function (rootID, transaction, mountDepth) {\n      \"production\" !== process.env.NODE_ENV ? invariant(!this.isMounted(), 'mountComponent(%s, ...): Can only mount an unmounted component. ' + 'Make sure to avoid storing components between renders or reusing a ' + 'single component instance in multiple places.', rootID) : invariant(!this.isMounted());\n      var ref = this._currentElement.ref;\n\n      if (ref != null) {\n        var owner = this._currentElement._owner;\n        ReactOwner.addComponentAsRefTo(this, ref, owner);\n      }\n\n      this._rootNodeID = rootID;\n      this._lifeCycleState = ComponentLifeCycle.MOUNTED;\n      this._mountDepth = mountDepth; // Effectively: return '';\n    },\n\n    /**\n     * Releases any resources allocated by `mountComponent`.\n     *\n     * NOTE: This does not remove any nodes from the DOM.\n     *\n     * Subclasses that override this method should make sure to invoke\n     * `ReactComponent.Mixin.unmountComponent.call(this)`.\n     *\n     * @internal\n     */\n    unmountComponent: function () {\n      \"production\" !== process.env.NODE_ENV ? invariant(this.isMounted(), 'unmountComponent(): Can only unmount a mounted component.') : invariant(this.isMounted());\n      var ref = this._currentElement.ref;\n\n      if (ref != null) {\n        ReactOwner.removeComponentAsRefFrom(this, ref, this._owner);\n      }\n\n      unmountIDFromEnvironment(this._rootNodeID);\n      this._rootNodeID = null;\n      this._lifeCycleState = ComponentLifeCycle.UNMOUNTED;\n    },\n\n    /**\n     * Given a new instance of this component, updates the rendered DOM nodes\n     * as if that instance was rendered instead.\n     *\n     * Subclasses that override this method should make sure to invoke\n     * `ReactComponent.Mixin.receiveComponent.call(this, ...)`.\n     *\n     * @param {object} nextComponent Next set of properties.\n     * @param {ReactReconcileTransaction} transaction\n     * @internal\n     */\n    receiveComponent: function (nextElement, transaction) {\n      \"production\" !== process.env.NODE_ENV ? invariant(this.isMounted(), 'receiveComponent(...): Can only update a mounted component.') : invariant(this.isMounted());\n      this._pendingElement = nextElement;\n      this.performUpdateIfNecessary(transaction);\n    },\n\n    /**\n     * If `_pendingElement` is set, update the component.\n     *\n     * @param {ReactReconcileTransaction} transaction\n     * @internal\n     */\n    performUpdateIfNecessary: function (transaction) {\n      if (this._pendingElement == null) {\n        return;\n      }\n\n      var prevElement = this._currentElement;\n      var nextElement = this._pendingElement;\n      this._currentElement = nextElement;\n      this.props = nextElement.props;\n      this._owner = nextElement._owner;\n      this._pendingElement = null;\n      this.updateComponent(transaction, prevElement);\n    },\n\n    /**\n     * Updates the component's currently mounted representation.\n     *\n     * @param {ReactReconcileTransaction} transaction\n     * @param {object} prevElement\n     * @internal\n     */\n    updateComponent: function (transaction, prevElement) {\n      var nextElement = this._currentElement; // If either the owner or a `ref` has changed, make sure the newest owner\n      // has stored a reference to `this`, and the previous owner (if different)\n      // has forgotten the reference to `this`. We use the element instead\n      // of the public this.props because the post processing cannot determine\n      // a ref. The ref conceptually lives on the element.\n      // TODO: Should this even be possible? The owner cannot change because\n      // it's forbidden by shouldUpdateReactComponent. The ref can change\n      // if you swap the keys of but not the refs. Reconsider where this check\n      // is made. It probably belongs where the key checking and\n      // instantiateReactComponent is done.\n\n      if (nextElement._owner !== prevElement._owner || nextElement.ref !== prevElement.ref) {\n        if (prevElement.ref != null) {\n          ReactOwner.removeComponentAsRefFrom(this, prevElement.ref, prevElement._owner);\n        } // Correct, even if the owner is the same, and only the ref has changed.\n\n\n        if (nextElement.ref != null) {\n          ReactOwner.addComponentAsRefTo(this, nextElement.ref, nextElement._owner);\n        }\n      }\n    },\n\n    /**\n     * Mounts this component and inserts it into the DOM.\n     *\n     * @param {string} rootID DOM ID of the root node.\n     * @param {DOMElement} container DOM element to mount into.\n     * @param {boolean} shouldReuseMarkup If true, do not insert markup\n     * @final\n     * @internal\n     * @see {ReactMount.render}\n     */\n    mountComponentIntoNode: function (rootID, container, shouldReuseMarkup) {\n      var transaction = ReactUpdates.ReactReconcileTransaction.getPooled();\n      transaction.perform(this._mountComponentIntoNode, this, rootID, container, transaction, shouldReuseMarkup);\n      ReactUpdates.ReactReconcileTransaction.release(transaction);\n    },\n\n    /**\n     * @param {string} rootID DOM ID of the root node.\n     * @param {DOMElement} container DOM element to mount into.\n     * @param {ReactReconcileTransaction} transaction\n     * @param {boolean} shouldReuseMarkup If true, do not insert markup\n     * @final\n     * @private\n     */\n    _mountComponentIntoNode: function (rootID, container, transaction, shouldReuseMarkup) {\n      var markup = this.mountComponent(rootID, transaction, 0);\n      mountImageIntoNode(markup, container, shouldReuseMarkup);\n    },\n\n    /**\n     * Checks if this component is owned by the supplied `owner` component.\n     *\n     * @param {ReactComponent} owner Component to check.\n     * @return {boolean} True if `owners` owns this component.\n     * @final\n     * @internal\n     */\n    isOwnedBy: function (owner) {\n      return this._owner === owner;\n    },\n\n    /**\n     * Gets another component, that shares the same owner as this one, by ref.\n     *\n     * @param {string} ref of a sibling Component.\n     * @return {?ReactComponent} the actual sibling Component.\n     * @final\n     * @internal\n     */\n    getSiblingByRef: function (ref) {\n      var owner = this._owner;\n\n      if (!owner || !owner.refs) {\n        return null;\n      }\n\n      return owner.refs[ref];\n    }\n  }\n};\nmodule.exports = ReactComponent;","map":null,"metadata":{},"sourceType":"script"}