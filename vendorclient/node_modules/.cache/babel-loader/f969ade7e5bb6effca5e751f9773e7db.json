{"ast":null,"code":"/**\n * Copyright 2013-2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactPropTransferer\n */\n\"use strict\";\n\nvar assign = require(\"./Object.assign\");\n\nvar emptyFunction = require(\"./emptyFunction\");\n\nvar invariant = require(\"./invariant\");\n\nvar joinClasses = require(\"./joinClasses\");\n\nvar warning = require(\"./warning\");\n\nvar didWarn = false;\n/**\n * Creates a transfer strategy that will merge prop values using the supplied\n * `mergeStrategy`. If a prop was previously unset, this just sets it.\n *\n * @param {function} mergeStrategy\n * @return {function}\n */\n\nfunction createTransferStrategy(mergeStrategy) {\n  return function (props, key, value) {\n    if (!props.hasOwnProperty(key)) {\n      props[key] = value;\n    } else {\n      props[key] = mergeStrategy(props[key], value);\n    }\n  };\n}\n\nvar transferStrategyMerge = createTransferStrategy(function (a, b) {\n  // `merge` overrides the first object's (`props[key]` above) keys using the\n  // second object's (`value`) keys. An object's style's existing `propA` would\n  // get overridden. Flip the order here.\n  return assign({}, b, a);\n});\n/**\n * Transfer strategies dictate how props are transferred by `transferPropsTo`.\n * NOTE: if you add any more exceptions to this list you should be sure to\n * update `cloneWithProps()` accordingly.\n */\n\nvar TransferStrategies = {\n  /**\n   * Never transfer `children`.\n   */\n  children: emptyFunction,\n\n  /**\n   * Transfer the `className` prop by merging them.\n   */\n  className: createTransferStrategy(joinClasses),\n\n  /**\n   * Transfer the `style` prop (which is an object) by merging them.\n   */\n  style: transferStrategyMerge\n};\n/**\n * Mutates the first argument by transferring the properties from the second\n * argument.\n *\n * @param {object} props\n * @param {object} newProps\n * @return {object}\n */\n\nfunction transferInto(props, newProps) {\n  for (var thisKey in newProps) {\n    if (!newProps.hasOwnProperty(thisKey)) {\n      continue;\n    }\n\n    var transferStrategy = TransferStrategies[thisKey];\n\n    if (transferStrategy && TransferStrategies.hasOwnProperty(thisKey)) {\n      transferStrategy(props, thisKey, newProps[thisKey]);\n    } else if (!props.hasOwnProperty(thisKey)) {\n      props[thisKey] = newProps[thisKey];\n    }\n  }\n\n  return props;\n}\n/**\n * ReactPropTransferer are capable of transferring props to another component\n * using a `transferPropsTo` method.\n *\n * @class ReactPropTransferer\n */\n\n\nvar ReactPropTransferer = {\n  TransferStrategies: TransferStrategies,\n\n  /**\n   * Merge two props objects using TransferStrategies.\n   *\n   * @param {object} oldProps original props (they take precedence)\n   * @param {object} newProps new props to merge in\n   * @return {object} a new object containing both sets of props merged.\n   */\n  mergeProps: function (oldProps, newProps) {\n    return transferInto(assign({}, oldProps), newProps);\n  },\n\n  /**\n   * @lends {ReactPropTransferer.prototype}\n   */\n  Mixin: {\n    /**\n     * Transfer props from this component to a target component.\n     *\n     * Props that do not have an explicit transfer strategy will be transferred\n     * only if the target component does not already have the prop set.\n     *\n     * This is usually used to pass down props to a returned root component.\n     *\n     * @param {ReactElement} element Component receiving the properties.\n     * @return {ReactElement} The supplied `component`.\n     * @final\n     * @protected\n     */\n    transferPropsTo: function (element) {\n      \"production\" !== process.env.NODE_ENV ? invariant(element._owner === this, '%s: You can\\'t call transferPropsTo() on a component that you ' + 'don\\'t own, %s. This usually means you are calling ' + 'transferPropsTo() on a component passed in as props or children.', this.constructor.displayName, typeof element.type === 'string' ? element.type : element.type.displayName) : invariant(element._owner === this);\n\n      if (\"production\" !== process.env.NODE_ENV) {\n        if (!didWarn) {\n          didWarn = true;\n          \"production\" !== process.env.NODE_ENV ? warning(false, 'transferPropsTo is deprecated. ' + 'See http://fb.me/react-transferpropsto for more information.') : null;\n        }\n      } // Because elements are immutable we have to merge into the existing\n      // props object rather than clone it.\n\n\n      transferInto(element.props, this.props);\n      return element;\n    }\n  }\n};\nmodule.exports = ReactPropTransferer;","map":null,"metadata":{},"sourceType":"script"}