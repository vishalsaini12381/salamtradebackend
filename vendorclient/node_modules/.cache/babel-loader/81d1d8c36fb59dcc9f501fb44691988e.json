{"ast":null,"code":"/**\n * Copyright 2013-2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule CompositionEventPlugin\n * @typechecks static-only\n */\n\"use strict\";\n\nvar EventConstants = require(\"./EventConstants\");\n\nvar EventPropagators = require(\"./EventPropagators\");\n\nvar ExecutionEnvironment = require(\"./ExecutionEnvironment\");\n\nvar ReactInputSelection = require(\"./ReactInputSelection\");\n\nvar SyntheticCompositionEvent = require(\"./SyntheticCompositionEvent\");\n\nvar getTextContentAccessor = require(\"./getTextContentAccessor\");\n\nvar keyOf = require(\"./keyOf\");\n\nvar END_KEYCODES = [9, 13, 27, 32]; // Tab, Return, Esc, Space\n\nvar START_KEYCODE = 229;\nvar useCompositionEvent = ExecutionEnvironment.canUseDOM && 'CompositionEvent' in window; // In IE9+, we have access to composition events, but the data supplied\n// by the native compositionend event may be incorrect. In Korean, for example,\n// the compositionend event contains only one character regardless of\n// how many characters have been composed since compositionstart.\n// We therefore use the fallback data while still using the native\n// events as triggers.\n\nvar useFallbackData = !useCompositionEvent || 'documentMode' in document && document.documentMode > 8 && document.documentMode <= 11;\nvar topLevelTypes = EventConstants.topLevelTypes;\nvar currentComposition = null; // Events and their corresponding property names.\n\nvar eventTypes = {\n  compositionEnd: {\n    phasedRegistrationNames: {\n      bubbled: keyOf({\n        onCompositionEnd: null\n      }),\n      captured: keyOf({\n        onCompositionEndCapture: null\n      })\n    },\n    dependencies: [topLevelTypes.topBlur, topLevelTypes.topCompositionEnd, topLevelTypes.topKeyDown, topLevelTypes.topKeyPress, topLevelTypes.topKeyUp, topLevelTypes.topMouseDown]\n  },\n  compositionStart: {\n    phasedRegistrationNames: {\n      bubbled: keyOf({\n        onCompositionStart: null\n      }),\n      captured: keyOf({\n        onCompositionStartCapture: null\n      })\n    },\n    dependencies: [topLevelTypes.topBlur, topLevelTypes.topCompositionStart, topLevelTypes.topKeyDown, topLevelTypes.topKeyPress, topLevelTypes.topKeyUp, topLevelTypes.topMouseDown]\n  },\n  compositionUpdate: {\n    phasedRegistrationNames: {\n      bubbled: keyOf({\n        onCompositionUpdate: null\n      }),\n      captured: keyOf({\n        onCompositionUpdateCapture: null\n      })\n    },\n    dependencies: [topLevelTypes.topBlur, topLevelTypes.topCompositionUpdate, topLevelTypes.topKeyDown, topLevelTypes.topKeyPress, topLevelTypes.topKeyUp, topLevelTypes.topMouseDown]\n  }\n};\n/**\n * Translate native top level events into event types.\n *\n * @param {string} topLevelType\n * @return {object}\n */\n\nfunction getCompositionEventType(topLevelType) {\n  switch (topLevelType) {\n    case topLevelTypes.topCompositionStart:\n      return eventTypes.compositionStart;\n\n    case topLevelTypes.topCompositionEnd:\n      return eventTypes.compositionEnd;\n\n    case topLevelTypes.topCompositionUpdate:\n      return eventTypes.compositionUpdate;\n  }\n}\n/**\n * Does our fallback best-guess model think this event signifies that\n * composition has begun?\n *\n * @param {string} topLevelType\n * @param {object} nativeEvent\n * @return {boolean}\n */\n\n\nfunction isFallbackStart(topLevelType, nativeEvent) {\n  return topLevelType === topLevelTypes.topKeyDown && nativeEvent.keyCode === START_KEYCODE;\n}\n/**\n * Does our fallback mode think that this event is the end of composition?\n *\n * @param {string} topLevelType\n * @param {object} nativeEvent\n * @return {boolean}\n */\n\n\nfunction isFallbackEnd(topLevelType, nativeEvent) {\n  switch (topLevelType) {\n    case topLevelTypes.topKeyUp:\n      // Command keys insert or clear IME input.\n      return END_KEYCODES.indexOf(nativeEvent.keyCode) !== -1;\n\n    case topLevelTypes.topKeyDown:\n      // Expect IME keyCode on each keydown. If we get any other\n      // code we must have exited earlier.\n      return nativeEvent.keyCode !== START_KEYCODE;\n\n    case topLevelTypes.topKeyPress:\n    case topLevelTypes.topMouseDown:\n    case topLevelTypes.topBlur:\n      // Events are not possible without cancelling IME.\n      return true;\n\n    default:\n      return false;\n  }\n}\n/**\n * Helper class stores information about selection and document state\n * so we can figure out what changed at a later date.\n *\n * @param {DOMEventTarget} root\n */\n\n\nfunction FallbackCompositionState(root) {\n  this.root = root;\n  this.startSelection = ReactInputSelection.getSelection(root);\n  this.startValue = this.getText();\n}\n/**\n * Get current text of input.\n *\n * @return {string}\n */\n\n\nFallbackCompositionState.prototype.getText = function () {\n  return this.root.value || this.root[getTextContentAccessor()];\n};\n/**\n * Text that has changed since the start of composition.\n *\n * @return {string}\n */\n\n\nFallbackCompositionState.prototype.getData = function () {\n  var endValue = this.getText();\n  var prefixLength = this.startSelection.start;\n  var suffixLength = this.startValue.length - this.startSelection.end;\n  return endValue.substr(prefixLength, endValue.length - suffixLength - prefixLength);\n};\n/**\n * This plugin creates `onCompositionStart`, `onCompositionUpdate` and\n * `onCompositionEnd` events on inputs, textareas and contentEditable\n * nodes.\n */\n\n\nvar CompositionEventPlugin = {\n  eventTypes: eventTypes,\n\n  /**\n   * @param {string} topLevelType Record from `EventConstants`.\n   * @param {DOMEventTarget} topLevelTarget The listening component root node.\n   * @param {string} topLevelTargetID ID of `topLevelTarget`.\n   * @param {object} nativeEvent Native browser event.\n   * @return {*} An accumulation of synthetic events.\n   * @see {EventPluginHub.extractEvents}\n   */\n  extractEvents: function (topLevelType, topLevelTarget, topLevelTargetID, nativeEvent) {\n    var eventType;\n    var data;\n\n    if (useCompositionEvent) {\n      eventType = getCompositionEventType(topLevelType);\n    } else if (!currentComposition) {\n      if (isFallbackStart(topLevelType, nativeEvent)) {\n        eventType = eventTypes.compositionStart;\n      }\n    } else if (isFallbackEnd(topLevelType, nativeEvent)) {\n      eventType = eventTypes.compositionEnd;\n    }\n\n    if (useFallbackData) {\n      // The current composition is stored statically and must not be\n      // overwritten while composition continues.\n      if (!currentComposition && eventType === eventTypes.compositionStart) {\n        currentComposition = new FallbackCompositionState(topLevelTarget);\n      } else if (eventType === eventTypes.compositionEnd) {\n        if (currentComposition) {\n          data = currentComposition.getData();\n          currentComposition = null;\n        }\n      }\n    }\n\n    if (eventType) {\n      var event = SyntheticCompositionEvent.getPooled(eventType, topLevelTargetID, nativeEvent);\n\n      if (data) {\n        // Inject data generated from fallback path into the synthetic event.\n        // This matches the property of native CompositionEventInterface.\n        event.data = data;\n      }\n\n      EventPropagators.accumulateTwoPhaseDispatches(event);\n      return event;\n    }\n  }\n};\nmodule.exports = CompositionEventPlugin;","map":null,"metadata":{},"sourceType":"script"}