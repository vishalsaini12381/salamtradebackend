{"ast":null,"code":"/**\n * Copyright 2013-2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactDOMSelect\n */\n\"use strict\";\n\nvar AutoFocusMixin = require(\"./AutoFocusMixin\");\n\nvar LinkedValueUtils = require(\"./LinkedValueUtils\");\n\nvar ReactBrowserComponentMixin = require(\"./ReactBrowserComponentMixin\");\n\nvar ReactCompositeComponent = require(\"./ReactCompositeComponent\");\n\nvar ReactElement = require(\"./ReactElement\");\n\nvar ReactDOM = require(\"./ReactDOM\");\n\nvar ReactUpdates = require(\"./ReactUpdates\");\n\nvar assign = require(\"./Object.assign\"); // Store a reference to the <select> `ReactDOMComponent`. TODO: use string\n\n\nvar select = ReactElement.createFactory(ReactDOM.select.type);\n\nfunction updateWithPendingValueIfMounted() {\n  /*jshint validthis:true */\n  if (this.isMounted()) {\n    this.setState({\n      value: this._pendingValue\n    });\n    this._pendingValue = 0;\n  }\n}\n/**\n * Validation function for `value` and `defaultValue`.\n * @private\n */\n\n\nfunction selectValueType(props, propName, componentName) {\n  if (props[propName] == null) {\n    return;\n  }\n\n  if (props.multiple) {\n    if (!Array.isArray(props[propName])) {\n      return new Error(\"The `\" + propName + \"` prop supplied to <select> must be an array if \" + \"`multiple` is true.\");\n    }\n  } else {\n    if (Array.isArray(props[propName])) {\n      return new Error(\"The `\" + propName + \"` prop supplied to <select> must be a scalar \" + \"value if `multiple` is false.\");\n    }\n  }\n}\n/**\n * If `value` is supplied, updates <option> elements on mount and update.\n * @param {ReactComponent} component Instance of ReactDOMSelect\n * @param {?*} propValue For uncontrolled components, null/undefined. For\n * controlled components, a string (or with `multiple`, a list of strings).\n * @private\n */\n\n\nfunction updateOptions(component, propValue) {\n  var multiple = component.props.multiple;\n  var value = propValue != null ? propValue : component.state.value;\n  var options = component.getDOMNode().options;\n  var selectedValue, i, l;\n\n  if (multiple) {\n    selectedValue = {};\n\n    for (i = 0, l = value.length; i < l; ++i) {\n      selectedValue['' + value[i]] = true;\n    }\n  } else {\n    selectedValue = '' + value;\n  }\n\n  for (i = 0, l = options.length; i < l; i++) {\n    var selected = multiple ? selectedValue.hasOwnProperty(options[i].value) : options[i].value === selectedValue;\n\n    if (selected !== options[i].selected) {\n      options[i].selected = selected;\n    }\n  }\n}\n/**\n * Implements a <select> native component that allows optionally setting the\n * props `value` and `defaultValue`. If `multiple` is false, the prop must be a\n * string. If `multiple` is true, the prop must be an array of strings.\n *\n * If `value` is not supplied (or null/undefined), user actions that change the\n * selected option will trigger updates to the rendered options.\n *\n * If it is supplied (and not null/undefined), the rendered options will not\n * update in response to user actions. Instead, the `value` prop must change in\n * order for the rendered options to update.\n *\n * If `defaultValue` is provided, any options with the supplied values will be\n * selected.\n */\n\n\nvar ReactDOMSelect = ReactCompositeComponent.createClass({\n  displayName: 'ReactDOMSelect',\n  mixins: [AutoFocusMixin, LinkedValueUtils.Mixin, ReactBrowserComponentMixin],\n  propTypes: {\n    defaultValue: selectValueType,\n    value: selectValueType\n  },\n  getInitialState: function () {\n    return {\n      value: this.props.defaultValue || (this.props.multiple ? [] : '')\n    };\n  },\n  componentWillMount: function () {\n    this._pendingValue = null;\n  },\n  componentWillReceiveProps: function (nextProps) {\n    if (!this.props.multiple && nextProps.multiple) {\n      this.setState({\n        value: [this.state.value]\n      });\n    } else if (this.props.multiple && !nextProps.multiple) {\n      this.setState({\n        value: this.state.value[0]\n      });\n    }\n  },\n  render: function () {\n    // Clone `this.props` so we don't mutate the input.\n    var props = assign({}, this.props);\n    props.onChange = this._handleChange;\n    props.value = null;\n    return select(props, this.props.children);\n  },\n  componentDidMount: function () {\n    updateOptions(this, LinkedValueUtils.getValue(this));\n  },\n  componentDidUpdate: function (prevProps) {\n    var value = LinkedValueUtils.getValue(this);\n    var prevMultiple = !!prevProps.multiple;\n    var multiple = !!this.props.multiple;\n\n    if (value != null || prevMultiple !== multiple) {\n      updateOptions(this, value);\n    }\n  },\n  _handleChange: function (event) {\n    var returnValue;\n    var onChange = LinkedValueUtils.getOnChange(this);\n\n    if (onChange) {\n      returnValue = onChange.call(this, event);\n    }\n\n    var selectedValue;\n\n    if (this.props.multiple) {\n      selectedValue = [];\n      var options = event.target.options;\n\n      for (var i = 0, l = options.length; i < l; i++) {\n        if (options[i].selected) {\n          selectedValue.push(options[i].value);\n        }\n      }\n    } else {\n      selectedValue = event.target.value;\n    }\n\n    this._pendingValue = selectedValue;\n    ReactUpdates.asap(updateWithPendingValueIfMounted, this);\n    return returnValue;\n  }\n});\nmodule.exports = ReactDOMSelect;","map":null,"metadata":{},"sourceType":"script"}