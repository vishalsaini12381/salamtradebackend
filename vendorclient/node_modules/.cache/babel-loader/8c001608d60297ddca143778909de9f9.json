{"ast":null,"code":"/**\n * Copyright 2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactLegacyElement\n */\n\"use strict\";\n\nvar ReactCurrentOwner = require(\"./ReactCurrentOwner\");\n\nvar invariant = require(\"./invariant\");\n\nvar monitorCodeUse = require(\"./monitorCodeUse\");\n\nvar warning = require(\"./warning\");\n\nvar legacyFactoryLogs = {};\n\nfunction warnForLegacyFactoryCall() {\n  if (!ReactLegacyElementFactory._isLegacyCallWarningEnabled) {\n    return;\n  }\n\n  var owner = ReactCurrentOwner.current;\n  var name = owner && owner.constructor ? owner.constructor.displayName : '';\n\n  if (!name) {\n    name = 'Something';\n  }\n\n  if (legacyFactoryLogs.hasOwnProperty(name)) {\n    return;\n  }\n\n  legacyFactoryLogs[name] = true;\n  \"production\" !== process.env.NODE_ENV ? warning(false, name + ' is calling a React component directly. ' + 'Use a factory or JSX instead. See: http://fb.me/react-legacyfactory') : null;\n  monitorCodeUse('react_legacy_factory_call', {\n    version: 3,\n    name: name\n  });\n}\n\nfunction warnForPlainFunctionType(type) {\n  var isReactClass = type.prototype && typeof type.prototype.mountComponent === 'function' && typeof type.prototype.receiveComponent === 'function';\n\n  if (isReactClass) {\n    \"production\" !== process.env.NODE_ENV ? warning(false, 'Did not expect to get a React class here. Use `Component` instead ' + 'of `Component.type` or `this.constructor`.') : null;\n  } else {\n    if (!type._reactWarnedForThisType) {\n      try {\n        type._reactWarnedForThisType = true;\n      } catch (x) {// just incase this is a frozen object or some special object\n      }\n\n      monitorCodeUse('react_non_component_in_jsx', {\n        version: 3,\n        name: type.name\n      });\n    }\n\n    \"production\" !== process.env.NODE_ENV ? warning(false, 'This JSX uses a plain function. Only React components are ' + 'valid in React\\'s JSX transform.') : null;\n  }\n}\n\nfunction warnForNonLegacyFactory(type) {\n  \"production\" !== process.env.NODE_ENV ? warning(false, 'Do not pass React.DOM.' + type.type + ' to JSX or createFactory. ' + 'Use the string \"' + type.type + '\" instead.') : null;\n}\n/**\n * Transfer static properties from the source to the target. Functions are\n * rebound to have this reflect the original source.\n */\n\n\nfunction proxyStaticMethods(target, source) {\n  if (typeof source !== 'function') {\n    return;\n  }\n\n  for (var key in source) {\n    if (source.hasOwnProperty(key)) {\n      var value = source[key];\n\n      if (typeof value === 'function') {\n        var bound = value.bind(source); // Copy any properties defined on the function, such as `isRequired` on\n        // a PropTypes validator.\n\n        for (var k in value) {\n          if (value.hasOwnProperty(k)) {\n            bound[k] = value[k];\n          }\n        }\n\n        target[key] = bound;\n      } else {\n        target[key] = value;\n      }\n    }\n  }\n} // We use an object instead of a boolean because booleans are ignored by our\n// mocking libraries when these factories gets mocked.\n\n\nvar LEGACY_MARKER = {};\nvar NON_LEGACY_MARKER = {};\nvar ReactLegacyElementFactory = {};\n\nReactLegacyElementFactory.wrapCreateFactory = function (createFactory) {\n  var legacyCreateFactory = function (type) {\n    if (typeof type !== 'function') {\n      // Non-function types cannot be legacy factories\n      return createFactory(type);\n    }\n\n    if (type.isReactNonLegacyFactory) {\n      // This is probably a factory created by ReactDOM we unwrap it to get to\n      // the underlying string type. It shouldn't have been passed here so we\n      // warn.\n      if (\"production\" !== process.env.NODE_ENV) {\n        warnForNonLegacyFactory(type);\n      }\n\n      return createFactory(type.type);\n    }\n\n    if (type.isReactLegacyFactory) {\n      // This is probably a legacy factory created by ReactCompositeComponent.\n      // We unwrap it to get to the underlying class.\n      return createFactory(type.type);\n    }\n\n    if (\"production\" !== process.env.NODE_ENV) {\n      warnForPlainFunctionType(type);\n    } // Unless it's a legacy factory, then this is probably a plain function,\n    // that is expecting to be invoked by JSX. We can just return it as is.\n\n\n    return type;\n  };\n\n  return legacyCreateFactory;\n};\n\nReactLegacyElementFactory.wrapCreateElement = function (createElement) {\n  var legacyCreateElement = function (type, props, children) {\n    if (typeof type !== 'function') {\n      // Non-function types cannot be legacy factories\n      return createElement.apply(this, arguments);\n    }\n\n    var args;\n\n    if (type.isReactNonLegacyFactory) {\n      // This is probably a factory created by ReactDOM we unwrap it to get to\n      // the underlying string type. It shouldn't have been passed here so we\n      // warn.\n      if (\"production\" !== process.env.NODE_ENV) {\n        warnForNonLegacyFactory(type);\n      }\n\n      args = Array.prototype.slice.call(arguments, 0);\n      args[0] = type.type;\n      return createElement.apply(this, args);\n    }\n\n    if (type.isReactLegacyFactory) {\n      // This is probably a legacy factory created by ReactCompositeComponent.\n      // We unwrap it to get to the underlying class.\n      if (type._isMockFunction) {\n        // If this is a mock function, people will expect it to be called. We\n        // will actually call the original mock factory function instead. This\n        // future proofs unit testing that assume that these are classes.\n        type.type._mockedReactClassConstructor = type;\n      }\n\n      args = Array.prototype.slice.call(arguments, 0);\n      args[0] = type.type;\n      return createElement.apply(this, args);\n    }\n\n    if (\"production\" !== process.env.NODE_ENV) {\n      warnForPlainFunctionType(type);\n    } // This is being called with a plain function we should invoke it\n    // immediately as if this was used with legacy JSX.\n\n\n    return type.apply(null, Array.prototype.slice.call(arguments, 1));\n  };\n\n  return legacyCreateElement;\n};\n\nReactLegacyElementFactory.wrapFactory = function (factory) {\n  \"production\" !== process.env.NODE_ENV ? invariant(typeof factory === 'function', 'This is suppose to accept a element factory') : invariant(typeof factory === 'function');\n\n  var legacyElementFactory = function (config, children) {\n    // This factory should not be called when JSX is used. Use JSX instead.\n    if (\"production\" !== process.env.NODE_ENV) {\n      warnForLegacyFactoryCall();\n    }\n\n    return factory.apply(this, arguments);\n  };\n\n  proxyStaticMethods(legacyElementFactory, factory.type);\n  legacyElementFactory.isReactLegacyFactory = LEGACY_MARKER;\n  legacyElementFactory.type = factory.type;\n  return legacyElementFactory;\n}; // This is used to mark a factory that will remain. E.g. we're allowed to call\n// it as a function. However, you're not suppose to pass it to createElement\n// or createFactory, so it will warn you if you do.\n\n\nReactLegacyElementFactory.markNonLegacyFactory = function (factory) {\n  factory.isReactNonLegacyFactory = NON_LEGACY_MARKER;\n  return factory;\n}; // Checks if a factory function is actually a legacy factory pretending to\n// be a class.\n\n\nReactLegacyElementFactory.isValidFactory = function (factory) {\n  // TODO: This will be removed and moved into a class validator or something.\n  return typeof factory === 'function' && factory.isReactLegacyFactory === LEGACY_MARKER;\n};\n\nReactLegacyElementFactory.isValidClass = function (factory) {\n  if (\"production\" !== process.env.NODE_ENV) {\n    \"production\" !== process.env.NODE_ENV ? warning(false, 'isValidClass is deprecated and will be removed in a future release. ' + 'Use a more specific validator instead.') : null;\n  }\n\n  return ReactLegacyElementFactory.isValidFactory(factory);\n};\n\nReactLegacyElementFactory._isLegacyCallWarningEnabled = true;\nmodule.exports = ReactLegacyElementFactory;","map":null,"metadata":{},"sourceType":"script"}