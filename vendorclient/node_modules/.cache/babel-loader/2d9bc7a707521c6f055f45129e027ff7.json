{"ast":null,"code":"/**\n * Copyright 2013-2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule instantiateReactComponent\n * @typechecks static-only\n */\n\"use strict\";\n\nvar warning = require(\"./warning\");\n\nvar ReactElement = require(\"./ReactElement\");\n\nvar ReactLegacyElement = require(\"./ReactLegacyElement\");\n\nvar ReactNativeComponent = require(\"./ReactNativeComponent\");\n\nvar ReactEmptyComponent = require(\"./ReactEmptyComponent\");\n/**\n * Given an `element` create an instance that will actually be mounted.\n *\n * @param {object} element\n * @param {*} parentCompositeType The composite type that resolved this.\n * @return {object} A new instance of the element's constructor.\n * @protected\n */\n\n\nfunction instantiateReactComponent(element, parentCompositeType) {\n  var instance;\n\n  if (\"production\" !== process.env.NODE_ENV) {\n    \"production\" !== process.env.NODE_ENV ? warning(element && (typeof element.type === 'function' || typeof element.type === 'string'), 'Only functions or strings can be mounted as React components.') : null; // Resolve mock instances\n\n    if (element.type._mockedReactClassConstructor) {\n      // If this is a mocked class, we treat the legacy factory as if it was the\n      // class constructor for future proofing unit tests. Because this might\n      // be mocked as a legacy factory, we ignore any warnings triggerd by\n      // this temporary hack.\n      ReactLegacyElement._isLegacyCallWarningEnabled = false;\n\n      try {\n        instance = new element.type._mockedReactClassConstructor(element.props);\n      } finally {\n        ReactLegacyElement._isLegacyCallWarningEnabled = true;\n      } // If the mock implementation was a legacy factory, then it returns a\n      // element. We need to turn this into a real component instance.\n\n\n      if (ReactElement.isValidElement(instance)) {\n        instance = new instance.type(instance.props);\n      }\n\n      var render = instance.render;\n\n      if (!render) {\n        // For auto-mocked factories, the prototype isn't shimmed and therefore\n        // there is no render function on the instance. We replace the whole\n        // component with an empty component instance instead.\n        element = ReactEmptyComponent.getEmptyComponent();\n      } else {\n        if (render._isMockFunction && !render._getMockImplementation()) {\n          // Auto-mocked components may have a prototype with a mocked render\n          // function. For those, we'll need to mock the result of the render\n          // since we consider undefined to be invalid results from render.\n          render.mockImplementation(ReactEmptyComponent.getEmptyComponent);\n        }\n\n        instance.construct(element);\n        return instance;\n      }\n    }\n  } // Special case string values\n\n\n  if (typeof element.type === 'string') {\n    instance = ReactNativeComponent.createInstanceForTag(element.type, element.props, parentCompositeType);\n  } else {\n    // Normal case for non-mocks and non-strings\n    instance = new element.type(element.props);\n  }\n\n  if (\"production\" !== process.env.NODE_ENV) {\n    \"production\" !== process.env.NODE_ENV ? warning(typeof instance.construct === 'function' && typeof instance.mountComponent === 'function' && typeof instance.receiveComponent === 'function', 'Only React Components can be mounted.') : null;\n  } // This actually sets up the internal instance. This will become decoupled\n  // from the public instance in a future diff.\n\n\n  instance.construct(element);\n  return instance;\n}\n\nmodule.exports = instantiateReactComponent;","map":null,"metadata":{},"sourceType":"script"}